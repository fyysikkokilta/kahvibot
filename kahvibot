#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Program that operates a Telegram bot which can tell if there is coffee based on
the entries in the database that the other 

Based on telepot (https://github.com/nickoala/telepot).
"""

import telepot
import telepot.loop
import config, db
import sys, time, syslog, signal

try:
  import matplotlib
  matplotlib.use("Agg") # has to be before other matplotlib imports to enable "headlessness"
  import matplotlib.pyplot as plt
  from matplotlib.dates import DateFormatter
  import datetime
  import tempfile
except ImportError:
  # mark that matplotlib is not available
  plt = False

"""
A thin wrapper class for telepot, keeps a database manager instance open to 
query the db.
"""
class KahviBot():
  def __init__(self, config_dict = None):

    if config_dict is None:
      self.config_dict = config.get_config_dict()

    # bind handling of SIGTERM to the appropriate function.
    signal.signal(signal.SIGTERM, self.handle_sigterm)

    self.poll_interval = float(config_dict["general"]["poll_interval"])
    self.bot_token = config_dict["telegram"]["bot_token"]

    self.bot = telepot.Bot(self.bot_token)

    self.dbManager = db.DatabaseManager(config_dict)

    if not plt:
      syslog.syslog(syslog.LOG_WARNING, "kahvibot: Plotting not available.")

    telepot.loop.MessageLoop(self.bot, self.handle_message).run_as_thread()
    # TODO: separate functions for handling message types
    # see: https://telepot.readthedocs.io/en/latest/reference.html#message-loop-and-webhook
    #telepot.loop.MessageLoop(self.bot, {"chat": self.handle_chat_message, "group": self.handle_group_message).run_as_thread()

    syslog.syslog(syslog.LOG_INFO, "kahvibot: Listening for Telegram messages.")

  """
  Keep the program running (see: https://telepot.readthedocs.io/en/latest/),
  not entirely sure if this is absolutely the best option, but going by the
  example here.
  """
  def run(self):
    try:
      while True:
        time.sleep(10)

    # handle manual stop
    except KeyboardInterrupt:
      self.handle_sigterm()

  """
  The function for handling telegram messages.

  TODOs / ideas:
  respond in english if the message is in english
  check if the coffee has been sitting over the night / if it's fresh
  move message handling / message contents to separate file(s), implement a
    dictionary structure or something
  handle /commands separately
  /plot command (?)
  proper /start message
  structure this function better, now everything is a mess of if-elses...
  handle inline messages (?)
  push notifications when there is coffee?
  if multiple people are asking if there is coffee but there isn't any, tell 
    them to make some
  """
  def handle_message(self, msg):
    content_type, chat_type, chat_id = telepot.glance(msg)
    bot_username = self.bot.getMe()["username"]
    reply_to = None
    bot = self.bot

    isGroup = chat_type == "group"

    if content_type != "text":
      return

    text = msg["text"]

    # if we are in a group, make sure that we are being talked to.
    # this removes the @bot_username from the end of the command
    try:
      command, command_target_username = text.split("@")
      command = command.strip(); 
      command_target_username = command_target_username.strip()

      if (isGroup and 
          # is the command aimed at someone else?
          (len(command.split()) == 1 and
          len(command_target_username.split()) == 1) and
          command_target_username.lower() != bot_username.lower()
          ):
        # We are in a group but the command is not aimed at us. Return.
        return

    except ValueError:
      # if the message starts with '/' but isn't of the form foo@bar and we are in a group, assume that there's no command.
      if text[0] == "/" and not isGroup:
        command = text
      else:
        command = None

    # if we are in a group, reply to the person who sent the command
    if isGroup:
      reply_to = msg["message_id"]

    if ("kahvi" in text or
        "tsufe" in text or # NOTE: in the case of tsufeBot, this may trigger even if the bot is only tagged, good idea?
        command == "/status"
        ):

      self.reply_current_coffee_amount(chat_id, reply_to)
      return

    if command == "/plot":
      self.reply_plot(chat_id, reply_to)
      return

  """
  This function gets called if an user has asked for the amount of coffee in
  the coffee maker right now. It figures out the amount of coffee and sends the
  appropriate response.
  """
  #TODO: handle language...
  def reply_current_coffee_amount(self, chat_id, reply_to = None, lang = "fi"):
    reply = None

    latest_measurement = self.dbManager.query_latest()
    if (
        latest_measurement is None or
        #TODO: is this hardcoded limit of 10 x the poll interval a good idea?
        time.time() - latest_measurement["timestamp"] > self.poll_interval * 10
        ):

      # TODO: implement this language dictionary thing (for other branches as well...)
      #reply = replies[lang]["dataNotAvailableMessage"]
      reply = "Mittausdataa ei valitettavasti ole saatavilla."
    
    else:
      # TODO: check for stale coffee
      #isStale = self.dbManager.query_stale_coffee()
      #if isStale: ....
      if latest_measurement["isCoffee"]:
        reply = u"Kiltiksellä on kahvia! \u2615"
        #TODO: incorporate nCups
        #reply = "Kiltahuoneella on noin {} kuppia kahvia".format(latest_measurement["nCups"])
      else:
        reply = "Kiltiksellä ei valitettavasti ole kahvia."
        # TODO: if many people ask for coffee, ask users to make some
        #if self.no_asked_for_coffee > self.ask_threshold:
        #  reply += " Sen perään on kysellyt viimeaikoina sinun lisäksesi {} muuta käyttäjää. Ehkä olisi aika keittää uusi pannu?".format(self.no_asked_for_coffee)
        #  # TODO: reset this counter when new coffee has been made
        #  self.no_asked_for_coffee += 1 

    self.bot.sendMessage(chat_id, reply, reply_to_message_id = reply_to)


  """
  Send a reply containing a plot of recent coffee measurements. If matplotlib 
  is not available, reply with a message saying so.
  This assumes that nCups is available in the database.
  """
  def reply_plot(self, chat_id, reply_to = None, lang = "fi"):

    if not plt:
      #TODO: language integration (?)
      reply = u"Kuvaajien piirtäminen ei valitettavasti onnistu tällä hetkellä."
      self.bot.sendMessage(chat_id, reply, reply_to_message_id = reply_to)
      return 

    # plot coffee for the last half hour 
    # TODO: hardcoding good idea? make configurable?
    length = 30 * 60
    
    data = self.dbManager.query_range(
        (time.time() - length, time.time()), 
        projection = {"_id" : False, "nCups": True, "timestamp": True}
        )

    # TODO: does this looping twice and rewinding cause issues with performance?
    x = [datetime.datetime.fromtimestamp(d["timestamp"]) for d in data]
    data.rewind()
    y = [d["nCups"] for d in data]

    fig = plt.figure()
    ax = fig.gca()
    ax.plot(x, y)

    # TODO: make plots prettier
    # TODO: latex stuff ? (might be a hassle if tex isn't installed)

    ax.xaxis.set_major_formatter(DateFormatter("%H:%M"))

    ax.set_xlabel(u"Klo")
    ax.set_ylabel(u"Kahvikuppia")
    ax.grid("on", linestyle = ":")
    fig.suptitle(u"Kahvin määrä") #, fontsize = ???)

    #TODO: is this necessary, hardcoding good idea?
    #ax.set_ylim((0, 10))

    with tempfile.TemporaryFile(suffix = ".png") as f:

      plt.savefig(f)

      f.seek(0)

      self.bot.sendPhoto(chat_id, f, reply_to_message_id = reply_to)


  """
  Function that gets executed upon exit (when systemd sends a SIGTERM). Handles
  closing of db connections etc. (if necessary).
  """
  def handle_sigterm(self, *kwargs):
    syslog.syslog(syslog.LOG_INFO, "kahvibot: Exiting.")

    sys.exit(0)


if __name__ == "__main__":

  cfg_dict = config.get_config_dict()

  kb = KahviBot(cfg_dict)

  # this will loop forever.
  kb.run()
