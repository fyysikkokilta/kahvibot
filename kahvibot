#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Program that operates a Telegram bot which can tell if there is coffee based on
the entries in the database that the other 

Based on telepot (https://github.com/nickoala/telepot).
"""

import telepot
import telepot.loop
import config, db
import sys, time, syslog, signal

"""
A thin wrapper class for telepot, keeps a database manager instance open to 
query the db.
"""
class KahviBot():
  def __init__(self, config_dict = None):

    if config_dict is None:
      self.config_dict = config.get_config_dict()

    # bind handling of SIGTERM to the appropriate function.
    signal.signal(signal.SIGTERM, self.handle_sigterm)

    self.poll_interval = float(config_dict["general"]["poll_interval"])
    self.bot_token = config_dict["telegram"]["bot_token"]

    self.bot = telepot.Bot(self.bot_token)

    self.dbManager = db.DatabaseManager(config_dict)

    telepot.loop.MessageLoop(self.bot, self.handle_message).run_as_thread()
    # TODO: separate functions for handling message types
    # see: https://telepot.readthedocs.io/en/latest/reference.html#message-loop-and-webhook
    #telepot.loop.MessageLoop(self.bot, {"chat": self.handle_chat_message, "group": self.handle_group_message).run_as_thread()

    syslog.syslog(syslog.LOG_INFO, "kahvibot: Listening for Telegram messages.")

  """
  Keep the program running (see: https://telepot.readthedocs.io/en/latest/),
  not entirely sure if this is absolutely the best option, but going by the
  example here.
  """
  def run(self):
    try:
      while True:
        time.sleep(10)

    # handle manual stop
    except KeyboardInterrupt:
      self.handle_sigterm()

  """
  The function for handling telegram messages.

  TODOs / ideas:
  respond in english if the message is in english
  check if the coffee has been sitting over the night / if it's fresh
  move message handling / message contents to separate file(s), implement a
    dictionary structure or something
  handle /commands separately
  /plot command (?)
  proper /start message
  structure this function better, now everything is a mess of if-elses...
  handle inline messages (?)
  push notifications when there is coffee?
  if multiple people are asking if there is coffee but there isn't any, tell 
    them to make some
  """
  def handle_message(self, msg):
    content_type, chat_type, chat_id = telepot.glance(msg)
    bot_username = self.bot.getMe()["username"]
    reply = None
    reply_to = None
    bot = self.bot

    isGroup = chat_type == "group"

    if content_type != "text":
      return

    text = msg["text"]

    #TODO: handle commands...
    if text[0] == "/":
      pass

    if isGroup:
      reply_to = msg["message_id"]

    if ("kahvi" in text or
        "tsufe" in text or
        (text.startswith("/status") and 
          (text.lower().endswith(bot_username.lower()) if isGroup else True)
          )
        ):

      self.reply_current_coffee_amount(chat_id, reply_to)
      return

  """
  This function gets called if an user has asked for the amount of coffee in
  the coffee maker right now. It figures out the amount of coffee and sends the
  appropriate response.
  """
  #TODO: handle language...
  def reply_current_coffee_amount(self, chat_id, reply_to = None, lang = "fi"):
    reply = None

    latest_measurement = self.dbManager.query_latest()
    if (
        latest_measurement is None or
        #TODO: is this hardcoded limit of 10 x the poll interval a good idea?
        time.time() - latest_measurement["timestamp"] > self.poll_interval * 10
        ):

      # TODO: implement this language dictionary thing (for other branches as well...)
      #reply = replies[lang]["dataNotAvailableMessage"]
      reply = "Mittausdataa ei valitettavasti ole saatavilla."
    
    else:
      # TODO: check for stale coffee
      #isStale = self.dbManager.query_stale_coffee()
      #if isStale: ....
      if latest_measurement["isCoffee"]:
        reply = u"Kiltiksellä on kahvia! \u2615"
        #TODO: incorporate nCups
        #reply = "Kiltahuoneella on noin {} kuppia kahvia".format(latest_measurement["nCups"])
      else:
        reply = "Kiltiksellä ei valitettavasti ole kahvia."
        # TODO: if many people ask for coffee, ask users to make some
        #if self.no_asked_for_coffee > self.ask_threshold:
        #  reply += " Sen perään on kysellyt viimeaikoina sinun lisäksesi {} muuta käyttäjää. Ehkä olisi aika keittää uusi pannu?".format(self.no_asked_for_coffee)
        #  # TODO: reset this counter when new coffee has been made
        #  self.no_asked_for_coffee += 1 

    self.bot.sendMessage(chat_id, reply, reply_to_message_id = reply_to)


  """
  Function that gets executed upon exit (when systemd sends a SIGTERM). Handles
  closing of db connections etc. (if necessary).
  """
  def handle_sigterm(self, *kwargs):
    syslog.syslog(syslog.LOG_INFO, "kahvibot: Exiting.")

    sys.exit(0)


if __name__ == "__main__":

  cfg_dict = config.get_config_dict()

  kb = KahviBot(cfg_dict)

  # this will loop forever.
  kb.run()
