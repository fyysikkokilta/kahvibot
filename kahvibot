#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Program that operates a Telegram bot which can tell if there is coffee based on
the entries in the database that the other 

Based on telepot (https://github.com/nickoala/telepot).
"""

import telepot
import telepot.loop
import config, db
import sys, time, syslog, signal

try:
  import matplotlib
  matplotlib.use("Agg") # has to be before other matplotlib imports to enable "headlessness"
  import matplotlib.pyplot as plt
  from matplotlib.dates import DateFormatter
  import datetime
  import tempfile
except ImportError:
  # mark that matplotlib is not available
  plt = False

"""
A thin wrapper class for telepot, keeps a database manager instance open to 
query the db.
"""
class KahviBot():
  def __init__(self, config_dict = None):

    if config_dict is None:
      self.config_dict = config.get_config_dict()

    telegram_config = config_dict["telegram"]

    # bind handling of SIGTERM to the appropriate function.
    signal.signal(signal.SIGTERM, self.handle_sigterm)

    self.poll_interval = float(config_dict["general"]["poll_interval"])
    self.max_ncups = float(config_dict["calibration"]["max_ncups"])

    bot_token = telegram_config["bot_token"]
    if not bot_token:
      raise ValueError("Telegram bot token not provided (did you set it in the configuration?)")
    self.bot_token = bot_token
    self.bot = telepot.Bot(self.bot_token)

    self.dbManager = db.DatabaseManager(config_dict)

    self.plot_length = float(telegram_config["plot_length"])
    if not plt:
      syslog.syslog(syslog.LOG_WARNING, "kahvibot: Plotting not available.")

    self.data_unavailable_threshold = float(telegram_config["data_unavailable_threshold"])

    # flush messages on startup.
    self.flush_messages()

    telepot.loop.MessageLoop(self.bot, self.handle_message).run_as_thread()
    # TODO: separate functions for handling message types
    # see: https://telepot.readthedocs.io/en/latest/reference.html#message-loop-and-webhook
    #telepot.loop.MessageLoop(self.bot, {"chat": self.handle_chat_message, "group": self.handle_group_message).run_as_thread()

    syslog.syslog(syslog.LOG_INFO, "kahvibot: Listening for Telegram messages.")

  """
  Flush messages in the update queue. Useful when the bot has been offline.
  """
  # TODO: notify users if their messages were flushed...
  def flush_messages(self):
    updates = self.bot.getUpdates()
    if updates:
      syslog.syslog(syslog.LOG_INFO, "kahvibot: Flushing {} messages.".format(len(updates)))
      # we assume that between here there's been no messages...
      self.bot.getUpdates(updates[-1]["update_id"] + 1)


  """
  Keep the program running (see: https://telepot.readthedocs.io/en/latest/),
  not entirely sure if this is absolutely the best option, but going by the
  example here.
  """
  def run(self):
    try:
      while True:
        time.sleep(10)

    # handle manual stop
    except KeyboardInterrupt:
      self.handle_sigterm()

  """
  The function for handling telegram messages.

  TODOs / ideas:
  respond in english if the message is in english
  check if the coffee has been sitting over the night / if it's fresh
  move message handling / message contents to separate file(s), implement a
    dictionary structure or something
  handle /commands separately
  /plot command (?)
  proper /start message
  structure this function better, now everything is a mess of if-elses...
  handle inline messages (?)
  push notifications when there is coffee?
  if multiple people are asking if there is coffee but there isn't any, tell 
    them to make some
  """
  def handle_message(self, msg):
    content_type, chat_type, chat_id = telepot.glance(msg)
    bot_username = self.bot.getMe()["username"]
    reply_to = None
    bot = self.bot

    isGroup = chat_type == "group"

    if content_type != "text":
      return

    text = msg["text"]

    # if we are in a group, make sure that we are being talked to.
    # this removes the @bot_username from the end of the command
    try:
      command, command_target_username = text.split("@")
      command = command.strip(); 
      command_target_username = command_target_username.strip()

      if (isGroup and 
          # is the command aimed at someone else?
          (len(command.split()) == 1 and
          len(command_target_username.split()) == 1) and
          command_target_username.lower() != bot_username.lower()
          ):
        # We are in a group but the command is not aimed at us. Return.
        return

    except ValueError:
      # if the message starts with '/' but isn't of the form foo@bar and we are in a group, assume that there's no command.
      if text[0] == "/" and not isGroup:
        command = text
      else:
        command = None

    # if we are in a group, reply to the person who sent the command
    if isGroup:
      reply_to = msg["message_id"]

    if ("kahvi" in text or
        "tsufe" in text or # NOTE: in the case of tsufeBot, this may trigger even if the bot is only tagged, good idea?
        command == "/status"
        ):

      self.reply_current_coffee_amount(chat_id, reply_to)
      return

    if command == "/plot":
      self.reply_plot(chat_id, reply_to)
      return

  """
  This function gets called if an user has asked for the amount of coffee in
  the coffee maker right now. It figures out the amount of coffee and sends the
  appropriate response.
  """
  #TODO: handle language...
  def reply_current_coffee_amount(self, chat_id, reply_to = None, lang = "fi"):
    reply = None

    latest_measurement = self.dbManager.query_latest()
    if (
        latest_measurement is None or
        time.time() - latest_measurement["timestamp"] > self.data_unavailable_threshold
        ):

      # TODO: implement this language dictionary thing (for other branches as well...)
      #reply = replies[lang]["dataNotAvailableMessage"]
      reply = "Mittausdataa ei valitettavasti ole saatavilla."
    
    else:
      # TODO: check for stale coffee
      #isStale = self.dbManager.query_stale_coffee()
      #if isStale: ....
      if latest_measurement["isCoffee"]:
        reply = u"Kiltiksellä on kahvia! \u2615"
        #TODO: incorporate nCups
        #reply = "Kiltahuoneella on noin {} kuppia kahvia".format(latest_measurement["nCups"])
      else:
        reply = "Kiltiksellä ei valitettavasti ole kahvia."
        # TODO: if many people ask for coffee, ask users to make some
        #if self.no_asked_for_coffee > self.ask_threshold:
        #  reply += " Sen perään on kysellyt viimeaikoina sinun lisäksesi {} muuta käyttäjää. Ehkä olisi aika keittää uusi pannu?".format(self.no_asked_for_coffee)
        #  # TODO: reset this counter when new coffee has been made
        #  self.no_asked_for_coffee += 1 

    self.bot.sendMessage(chat_id, reply, reply_to_message_id = reply_to)


  """
  Send a reply containing a plot of recent coffee measurements. If matplotlib 
  is not available, reply with a message saying so.
  This assumes that nCups is available in the database.
  """
  def reply_plot(self, chat_id, reply_to = None, lang = "fi"):
    # This will be sent as a reply if something is wrong.
    error_msg = u"Kuvaajien piirtäminen ei valitettavasti onnistu tällä hetkellä."

    self.bot.sendChatAction(chat_id, "typing")

    if not plt:
      #TODO: language integration (?)
      self.bot.sendMessage(chat_id, error_msg, reply_to_message_id = reply_to)
      return 

    t = time.time()
    data = self.dbManager.query_range(
        (t - self.plot_length * 60, t), 
        projection = {"_id" : False, "nCups": True, "timestamp": True}
        )

    if data.count() == 0:
      self.bot.sendMessage(chat_id, error_msg, reply_to_message_id = reply_to)
      return


    # TODO: does this looping twice and rewinding cause issues with performance?
    x = [datetime.datetime.fromtimestamp(d["timestamp"]) for d in data]
    data.rewind()
    y = [d["nCups"] for d in data]

    fig = plt.figure()
    ax = fig.gca()
    ax.plot(x, y)

    # TODO: make plots prettier
    # TODO: latex stuff ? (might be a hassle if tex isn't installed)

    ax.xaxis.set_major_formatter(DateFormatter("%H:%M"))

    ax.set_xlabel(u"Klo")
    ax.set_ylabel(u"Kahvikuppia")
    ax.grid("on", linestyle = ":")
    fig.suptitle(u"Kahvin määrä") #, fontsize = ???)

    ax.set_ylim((0, self.max_ncups))

    with tempfile.TemporaryFile(suffix = ".png") as f:

      plt.savefig(f)

      f.seek(0)

      self.bot.sendPhoto(chat_id, f, reply_to_message_id = reply_to)


  """
  Function that gets executed upon exit (when systemd sends a SIGTERM). Handles
  closing of db connections etc. (if necessary).
  """
  def handle_sigterm(self, *kwargs):
    syslog.syslog(syslog.LOG_INFO, "kahvibot: Exiting.")

    sys.exit(0)


if __name__ == "__main__":
  import argparse

  ap = argparse.ArgumentParser(description = "Run a telegram bot that tells how much coffee there is.")

  ap.add_argument("-c", "--config",
      dest = "config_file",
      help = "Use CONFIG_FILE as the configuration file instead of the default."
      )

  args = ap.parse_args()

  cfg_dict = config.get_config_dict(args.config_file)

  kb = KahviBot(cfg_dict)

  # this will loop forever.
  kb.run()
