#!/usr/bin/env python3

"""
The main measurement program, responsible for polling the sensor periodically 
and inserting the results into a database. 

Must be run as root (to access the GPIO and to create a PID file).
"""

import sys, os, time
import syslog
import threading
import signal
import db
import config
import sensor as sensorPackage

MEASUREMENT_THREAD_NAME = "MeasurementThread"

"""
The main function, containing an infinite loop that polls the sensor 
periodically as specified by poll_interval in the config and writes the results
to a database.
"""
# TODO: see https://stackoverflow.com/questions/13069634/python-daemon-and-systemd-service
def main(config_dict = None):

  if config_dict is None:
    config_dict = config.get_config_dict()

  # bind handling of SIGTERM to the appropriate function.
  signal.signal(signal.SIGTERM, handle_sigterm)

  # set up sensor and poll intervals
  sensor = sensorPackage.Sensor(config_dict)
  poll_interval = float(config_dict["general"]["poll_interval"])
  syslog.syslog(
      syslog.LOG_INFO, 
      "Poll interval: {} s, averaging time: {} s.".format(
        poll_interval, sensor.averaging_time
        )
      )

  #TODO: make this in a more sensible manner
  if sensor.is_dummy:
    _write_record = write_record_dummy
    #raise NotImplementedError("Database handling of dummy sensor is not yet implemented...")
  else:
    _write_record = write_record

  # the time it took to start the measurement thread,
  # used in an attempt to minimize clock error.
  delta_t = 0

  # The thread handling sensor polling and database writing.
  thread = None


  #TODO: wait so that measurements are always evenly spaced (assuming that poll_interval is the same)
  #time.sleep(time.time() % poll_interval)

  while True:

    # if the previous measurement is in progress, skip a measurement. 
    # shouldn't be a problem if the difference between poll_interval and
    # averaging_time is sufficiently large.
    if thread is not None and thread.is_alive():
      syslog.syslog(syslog.LOG_WARNING, "Sensor was busy, skipping poll.")
      delta_t = 0.

    else:
      delta_t = -1 * time.time()
      thread = threading.Thread(
            target = _write_record,
            args = [sensor, config_dict], # TODO: how does this work with threading...
            name = MEASUREMENT_THREAD_NAME
          )
      thread.start()
      delta_t += time.time()

    time.sleep(poll_interval - delta_t)


"""
Function that does everything necessary (closing db connections etc.) before 
exiting.
"""
def handle_sigterm(*kwargs):

  syslog.syslog(syslog.LOG_INFO, "Cleaning up GPIO...")
  sensorPackage.GPIO.cleanup()

  syslog.syslog(syslog.LOG_INFO, "Waiting for measurements to finish...")
  # NOTE: assuming that there are no other non-daemon threads running...
  for t in threading.enumerate():
    if t.name == MEASUREMENT_THREAD_NAME:
      t.join()

  syslog.syslog(syslog.LOG_INFO, "Exiting.")

  sys.exit(0)

"""
This function polls the sensor and writes the result to the database using 
the given db_conection. The function is supposed to be called in its own 
thread so the timing of poll intervals doesn't get messed up.
"""
# TODO: better name
def write_record(sensor, config_dict):

  # initialize db connections in this thread to avoid problems..
  dbManager = db.DatabaseManager(config_dict)
  data = sensor.poll()

  t = time.time()

  data["timestamp"] = t

  dbManager.insert_data(data)

"""
A function that writes the data to a dummy output file instead, used for 
testing if GPIO is not available.
"""
def write_record_dummy(sensor, *kwargs):
  import json
  path = os.path

  # initialize db connections in this thread to avoid problems..
  dbManager = db.DatabaseManager(config_dict)
  data = sensor.poll()

  t = time.time()

  data["timestamp"] = t

  target_dir = path.join(
        path.dirname(path.abspath(__file__)),
        "db",
        "dummy",
        )

  if not path.exists(target_dir):
    syslog.syslog(syslog.LOG_WARNING, "Creating folder {} for dummy database output.".format(target_dir))
    os.makedirs(target_dir)

  os.chdir(target_dir)

  # NOTE: this assumes that the file isn't open by someone else...
  with open("dummy.txt", "a") as f:
    f.write(json.dumps(data) + "\n")



if __name__ == "__main__":

  import argparse

  parser = argparse.ArgumentParser("Main script for coffee measurement daemon.")

  parser.add_argument("-c", "--config", 
      dest = "config_path", default = None, 
      action="store",
      help = "Read configuration file from CONFIG_PATH instead of the default."
      )

  args = parser.parse_args()

  config_dict = None

  if args.config_path:
    config_dict = config.get_config_dict(args.config_path)

  main(config_dict = config_dict)
